<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>OpenTracing语义标准 - Even - A super concise theme for Hugo</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="google-site-verification" content="eiWlv8y03_FJ7YItP72quHoi0GlI-t4_tNYv7uETwKw" />

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="刘超雄" />
  <meta name="description" content="版本号: 1.1 综述 这是正式的OpenTracing语义标准。OpenTracing是一个跨编程语言的标准，此文档会避免具有语言特性的概念。比如，" />

  <meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.31.1" />


<link rel="canonical" href="http://www.cffyh.cc/post/opentracing/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" href="/favicon.ico" />
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=2.7.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">

<meta property="og:title" content="OpenTracing语义标准" />
<meta property="og:description" content="版本号: 1.1 综述 这是正式的OpenTracing语义标准。OpenTracing是一个跨编程语言的标准，此文档会避免具有语言特性的概念。比如，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://www.cffyh.cc/post/opentracing/" />



<meta property="article:published_time" content="2017-12-28T16:08:37&#43;08:00"/>

<meta property="article:modified_time" content="2017-12-28T16:08:37&#43;08:00"/>











<meta itemprop="name" content="OpenTracing语义标准">
<meta itemprop="description" content="版本号: 1.1 综述 这是正式的OpenTracing语义标准。OpenTracing是一个跨编程语言的标准，此文档会避免具有语言特性的概念。比如，">


<meta itemprop="datePublished" content="2017-12-28T16:08:37&#43;08:00" />
<meta itemprop="dateModified" content="2017-12-28T16:08:37&#43;08:00" />
<meta itemprop="wordCount" content="5283">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="OpenTracing语义标准"/>
<meta name="twitter:description" content="版本号: 1.1 综述 这是正式的OpenTracing语义标准。OpenTracing是一个跨编程语言的标准，此文档会避免具有语言特性的概念。比如，"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Even</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Even</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">OpenTracing语义标准</h1>

      <div class="post-meta">
        <span class="post-time"> 2017-12-28 </span>
        
        
        
      </div>
    </header>

    
    

    
    <div class="post-content">
      

<p><strong>版本号:</strong> 1.1</p>

<h2 id="综述">综述</h2>

<p>这是正式的OpenTracing语义标准。OpenTracing是一个跨编程语言的标准，此文档会避免具有语言特性的概念。比如，我们在文档中使用&rdquo;interface&rdquo;，因为所有的语言都包含&rdquo;interface&rdquo;这种概念。</p>

<h3 id="版本命名策略">版本命名策略</h3>

<p>OpenTracing标准使用<code>Major.Minor</code>版本命名策略（即：大版本.小版本），但不包含<code>.Patch</code>版本（即：补丁版本）。如果标准做出不向前兼容的改变，则使用“主版本”号提升。如果是向前兼容的改进，则进行小版本号提升，例如加入新的标准tag, log和SpanContext引用类型。（如果你想知道更多关于制定此版本政策的原因，可参考<a href="https://github.com/opentracing/specification/issues/2#issuecomment-261740811">specification#2</a>）</p>

<h2 id="opentracing数据模型">OpenTracing数据模型</h2>

<p>OpenTracing中的<strong>Trace</strong>（调用链）通过归属于此调用链的<strong>Span</strong>来隐性的定义。
特别说明，一条<strong>Trace</strong>（调用链）可以被认为是一个由多个<strong>Span</strong>组成的有向无环图（DAG图），
<strong>Span</strong>与<strong>Span</strong>的关系被命名为<strong>References</strong>。</p>

<p><strong>译者注: Span，可以被翻译为跨度，可以被理解为一次方法调用, 一个程序块的调用, 或者一次RPC/数据库访问.只要是一个具有完整时间周期的程序访问，都可以被认为是一个span.在此译本中，为了便于理解，Span和其他标准内声明的词汇，全部不做名词翻译。</strong></p>

<p>例如：下面的示例<strong>Trace</strong>就是由8个<strong>Span</strong>组成：</p>

<pre><code>单个Trace中，span间的因果关系


        [Span A]  ←←←(the root span)
            |
     +------+------+
     |             |
 [Span B]      [Span C] ←←←(Span C 是 Span A 的孩子节点, ChildOf)
     |             |
 [Span D]      +---+-------+
               |           |
           [Span E]    [Span F] &gt;&gt;&gt; [Span G] &gt;&gt;&gt; [Span H]
                                       ↑
                                       ↑
                                       ↑
                         (Span G 在 Span F 后被调用, FollowsFrom)

</code></pre>

<p>有些时候，使用下面这种，基于时间轴的时序图可以更好的展现<strong>Trace</strong>（调用链）：</p>

<pre><code>单个Trace中，span间的时间关系


––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–––––––|–&gt; time

 [Span A···················································]
   [Span B··············································]
      [Span D··········································]
    [Span C········································]
         [Span E·······]        [Span F··] [Span G··] [Span H··]
</code></pre>

<p>每个<strong>Span</strong>包含以下的状态:（译者注：由于这些状态会反映在OpenTracing API中，所以会保留部分英文说明）</p>

<ul>
<li>An operation name，操作名称</li>
<li>A start timestamp，起始时间</li>
<li>A finish timestamp，结束时间</li>
<li><strong>Span Tag</strong>，一组键值对构成的Span标签集合。键值对中，键必须为string，值可以是字符串，布尔，或者数字类型。</li>
<li><strong>Span Log</strong>，一组span的日志集合。
每次log操作包含一个键值对，以及一个时间戳。
键值对中，键必须为string，值可以是任意类型。
但是需要注意，不是所有的支持OpenTracing的Tracer,都需要支持所有的值类型。</li>
<li><strong>SpanContext</strong>，Span上下文对象 (下面会详细说明)</li>
<li><strong>References</strong>(Span间关系)，相关的零个或者多个Span（<strong>Span</strong>间通过<strong>SpanContext</strong>建立这种关系）</li>
</ul>

<p>每一个<strong>SpanContext</strong>包含以下状态：</p>

<ul>
<li>任何一个OpenTracing的实现，都需要将当前调用链的状态（例如：trace和span的id），依赖一个独特的Span去跨进程边界传输</li>
<li><strong>Baggage Items</strong>，Trace的随行数据，是一个键值对集合，它存在于trace中，也需要跨进程边界传输</li>
</ul>

<h3 id="span间关系">Span间关系</h3>

<p>一个Span可以与一个或者多个<strong>SpanContexts</strong>存在因果关系。OpenTracing目前定义了两种关系：<code>ChildOf</code>（父子） 和 <code>FollowsFrom</code>（跟随）。<strong>这两种关系明确的给出了两个父子关系的Span的因果模型。</strong> 将来，OpenTracing可能提供非因果关系的span间关系。（例如：span被批量处理，span被阻塞在同一个队列中，等等）。</p>

<p><strong><code>ChildOf</code> 引用:</strong> 一个span可能是一个父级span的孩子，即&rdquo;ChildOf&rdquo;关系。在&rdquo;ChildOf&rdquo;引用关系下，父级span某种程度上取决于子span。下面这些情况会构成&rdquo;ChildOf&rdquo;关系：</p>

<ul>
<li>一个RPC调用的服务端的span，和RPC服务客户端的span构成ChildOf关系</li>
<li>一个sql insert操作的span，和ORM的save方法的span构成ChildOf关系</li>
<li>很多span可以并行工作（或者分布式工作）都可能是一个父级的span的子项，他会合并所有子span的执行结果，并在指定期限内返回</li>
</ul>

<p>下面都是合理的表述一个&rdquo;ChildOf&rdquo;关系的父子节点关系的时序图。</p>

<pre><code>    [-Parent Span---------]
         [-Child Span----]

    [-Parent Span--------------]
         [-Child Span A----]
          [-Child Span B----]
        [-Child Span C----]
         [-Child Span D---------------]
         [-Child Span E----]
</code></pre>

<p><strong><code>FollowsFrom</code> 引用:</strong> 一些父级节点不以任何方式依赖他们子节点的执行结果，这种情况下，我们说这些子span和父span之间是&rdquo;FollowsFrom&rdquo;的因果关系。&rdquo;FollowsFrom&rdquo;关系可以被分为很多不同的子类型，未来版本的OpenTracing中将正式的区分这些类型</p>

<p>下面都是合理的表述一个&rdquo;FollowFrom&rdquo;关系的父子节点关系的时序图。</p>

<pre><code>    [-Parent Span-]  [-Child Span-]


    [-Parent Span--]
     [-Child Span-]


    [-Parent Span-]
                [-Child Span-]
</code></pre>

<h2 id="opentracing-api">OpenTracing API</h2>

<p>OpenTracing标准中有三个重要的相互关联的类型，分别是<code>Tracer</code>, <code>Span</code> 和 <code>SpanContext</code>。下面，我们分别描述每种类型的行为，一般来说，每个行为都会在各语言实现层面上，会演变成一个方法，而实际上由于方法重载，很可能演变成一系列相似的方法。</p>

<p>当我们讨论“可选”参数时，需要强调的是，不同的语言针对可选参数有不同理解，概念和实现方式 。例如，在Go中，我们习惯使用&rdquo;functional Options&rdquo;，而在Java中，我们可能使用builder模式。</p>

<h3 id="tracer"><code>Tracer</code></h3>

<p><code>Tracer</code>接口用来创建<code>Span</code>，以及处理如何处理<code>Inject</code>(serialize) 和 <code>Extract</code> (deserialize)，用于跨进程边界传递。它具有如下官方能力：</p>

<h4 id="创建一个新-span">创建一个新<code>Span</code></h4>

<p>必填参数</p>

<ul>
<li><strong>operation name</strong>, 操作名, 一个具有可读性的字符串，代表这个span所做的工作（例如：RPC方法名，方法名，或者一个大型计算中的某个阶段或子任务）。操作名应该是一个<strong>抽象、通用，明确、具有统计意义</strong>的名称。因此，<code>&quot;get_user&quot;</code> 作为操作名，比 <code>&quot;get_user/314159&quot;</code>更好。</li>
</ul>

<p>例如，假设一个获取账户信息的span会有如下可能的名称：</p>

<table>
<thead>
<tr>
<th align="left">操作名</th>
<th align="left">指导意见</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>get</code></td>
<td align="left">太抽象</td>
</tr>

<tr>
<td align="left"><code>get_account/792</code></td>
<td align="left">太明确</td>
</tr>

<tr>
<td align="left"><code>get_account</code></td>
<td align="left">正确的操作名，关于<code>account_id=792</code>的信息应该使用<a href="#tags">Tag</a>操作</td>
</tr>
</tbody>
</table>

<p>可选参数</p>

<ul>
<li>零个或者多个关联（<strong>references</strong>）的<code>SpanContext</code>，如果可能，同时快速指定关系类型，<code>ChildOf</code> 还是 <code>FollowsFrom</code>。</li>
<li>一个可选的显性传递的<strong>开始时间</strong>；如果忽略，当前时间被用作开始时间。</li>
<li>零个或者多个<strong>tag</strong>。</li>
</ul>

<p><strong>返回值</strong>，返回一个已经启动<code>Span</code>实例（已启动，但未结束。译者注：英语上started和finished理解容易混淆）</p>

<h4 id="将-spancontext-上下文inject-注入-到carrier">将<code>SpanContext</code>上下文Inject（注入）到carrier</h4>

<p>必填参数</p>

<ul>
<li><strong><code>SpanContext</code></strong>实例</li>
<li><strong>format</strong>（格式化）描述，一般会是一个字符串常量，但不做强制要求。通过此描述，通知<code>Tracer</code>实现，如何对<code>SpanContext</code>进行编码放入到carrier中。</li>
<li><strong>carrier</strong>，根据<strong>format</strong>确定。<code>Tracer</code>实现根据<strong>format</strong>声明的格式，将<code>SpanContext</code>序列化到carrier对象中。</li>
</ul>

<h4 id="将-spancontext-上下文从carrier中extract-提取">将<code>SpanContext</code>上下文从carrier中Extract（提取）</h4>

<p>必填参数</p>

<ul>
<li><strong>format</strong>（格式化）描述，一般会是一个字符串常量，但不做强制要求。通过此描述，通知<code>Tracer</code>实现，如何从carrier中解码<code>SpanContext</code>。</li>
<li><strong>carrier</strong>，根据<strong>format</strong>确定。<code>Tracer</code>实现根据<strong>format</strong>声明的格式，从carrier中解码<code>SpanContext</code>。</li>
</ul>

<p><strong>返回值</strong>，返回一个<code>SpanContext</code>实例，可以使用这个<code>SpanContext</code>实例，通过<code>Tracer</code>创建新的<code>Span</code>。</p>

<h4 id="注意-对于inject-注入-和extract-提取-format-是必须的">注意，对于Inject（注入）和Extract（提取），<strong>format</strong>是必须的。</h4>

<p>Inject（注入）和Extract（提取）依赖于可扩展的<strong>format</strong>参数。<strong>format</strong>参数规定了另一个参数&rdquo;carrier&rdquo;的类型，同时约束了&rdquo;carrier&rdquo;中<code>SpanContext</code>是如何编码的。所有的Tracer实现，都必须支持下面的<strong>format</strong>。</p>

<ul>
<li><strong>Text Map</strong>: 基于字符串：字符串的map,对于key和value不约束字符集。</li>
<li><strong>HTTP Headers</strong>: 适合作为HTTP头信息的，基于字符串：字符串的map。（<a href="https://tools.ietf.org/html/rfc7230#section-3.2.4">RFC 7230</a>.在工程实践中，如何处理HTTP头具有多样性，强烈建议tracer的使用者谨慎使用HTTP头的键值空间和转义符）</li>
<li><strong>Binary</strong>: 一个简单的二进制大对象，记录<code>SpanContext</code>的信息。</li>
</ul>

<h3 id="span"><code>Span</code></h3>

<p>当<code>Span</code>结束后(<code>span.finish()</code>)，除了通过<code>Span</code>获取<code>SpanContext</code>外，下列其他所有方法都不允许被调用。</p>

<h4 id="除了通过-span-获取-spancontext">除了通过<code>Span</code>获取<code>SpanContext</code></h4>

<p>不需要任何参数。</p>

<p><strong>返回值</strong>，<code>Span</code>构建时传入的<code>SpanContext</code>。这个返回值在<code>Span</code>结束后(<code>span.finish()</code>)，依然可以使用。</p>

<h4 id="复写操作名-operation-name">复写操作名（operation name）</h4>

<p>必填参数</p>

<ul>
<li>新的操作名<strong>operation name</strong>，覆盖构建<code>Span</code>时，传入的操作名。</li>
</ul>

<h4 id="结束-span">结束<code>Span</code></h4>

<p>可选参数</p>

<ul>
<li>一个明确的<strong>完成时间</strong>;如果省略此参数，使用当前时间作为完成时间。</li>
</ul>

<h4 id="为-span-设置tag">为<code>Span</code>设置tag</h4>

<p>必填参数</p>

<ul>
<li>tag key，必须是string类型</li>
<li>tag value，类型为字符串，布尔或者数字</li>
</ul>

<p>注意，OpenTracing标准包含<strong><a href="./semantic_conventions.md">&ldquo;standard tags，标准Tag&rdquo;</a></strong>，此文档中定义了Tag的标准含义。</p>

<h4 id="log结构化数据">Log结构化数据</h4>

<p>必填参数</p>

<ul>
<li>一个或者多个键值对，其中键必须是字符串类型，值可以是任意类型。某些OpenTracing实现，可能支持更多的log值类型。</li>
</ul>

<p>可选参数</p>

<ul>
<li>一个明确的时间戳。如果指定时间戳，那么它必须在span的开始和结束时间之内。</li>
</ul>

<p>注意，OpenTracing标准包含<strong><a href="./semantic_conventions.md">&ldquo;standard log keys，标准log的键&rdquo;</a></strong>，此文档中定义了这些键的标准含义。</p>

<h4 id="设置一个-baggage-随行数据-元素">设置一个<strong>baggage</strong>（随行数据）元素</h4>

<p>Baggage元素是一个键值对集合，将这些值设置给给定的<code>Span</code>，<code>Span</code>的<code>SpanContext</code>，以及<strong>所有和此<code>Span</code>有直接或者间接关系的本地<code>Span</code>。</strong> 也就是说，baggage元素随trace一起保持在带内传递。（译者注：带内传递，在这里指，随应用程序调用过程一起传递）</p>

<p>Baggage元素为OpenTracing的实现全栈集成，提供了强大的功能 （例如：任意的应用程序数据，可以在移动端创建它，显然的，它会一直传递了系统最底层的存储系统。由于它如此强大的功能，他也会产生巨大的开销，请小心使用此特性。</p>

<p>再次强调，请谨慎使用此特性。每一个键值都会被拷贝到每一个本地和*远程*的下级相关的span中，因此，总体上，他会有明显的网络和CPU开销。</p>

<p>必填参数</p>

<ul>
<li><strong>baggage key</strong>, 字符串类型</li>
<li><strong>baggage value</strong>, 字符串类型</li>
</ul>

<h4 id="获取一个-baggage-元素">获取一个<strong>baggage</strong>元素</h4>

<p>必填参数</p>

<ul>
<li><strong>baggage key</strong>, 字符串类型</li>
</ul>

<p><strong>返回值</strong>，相应的<strong>baggage value</strong>,或者可以标识元素值不存在的返回值（译者注：如Null）。</p>

<h3 id="spancontext"><code>SpanContext</code></h3>

<p>相对于OpenTracing中其他的功能，<code>SpanContext</code>更多的是一个“概念”。也就是说，OpenTracing实现中，需要重点考虑，并提供一套自己的API。
OpenTracing的使用者仅仅需要，在创建span、向传输协议Inject（注入）和从传输协议中Extract（提取）时，使用<code>SpanContext</code>和<a href="#references"><strong>references</strong></a>，</p>

<p>OpenTracing要求，<code>SpanContext</code>是<strong>不可变</strong>的，目的是防止由于<code>Span</code>的结束和相互关系，造成的复杂生命周期问题。</p>

<h4 id="遍历所有的baggage元素">遍历所有的baggage元素</h4>

<p>遍历模型依赖于语言，实现方式可能不一致。在语义上，要求调用者可以通过给定的<code>SpanContext</code>实例，高效的遍历所有的baggage元素</p>

<h3 id="nooptracer"><code>NoopTracer</code></h3>

<p>所有的OpenTracing API实现，必须提供某种方式的<code>NoopTracer</code>实现。<code>NoopTracer</code>可以被用作控制或者测试时，进行无害的inject注入（等等）。例如，在 OpenTracing-Java实现中，<code>NoopTracer</code>在他自己的模块中。</p>

<h3 id="可选-api-元素">可选 API 元素</h3>

<p>有些语言的OpenTracing实现，为了在串行处理中，传递活跃的<code>Span</code>或<code>SpanContext</code>，提供了一些工具类。例如，<code>opentracing-go</code>中，通过<code>context.Context</code>机制，可以设置和获取活跃的<code>Span</code>。</p>

    </div>

    
    

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/concurrent/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">多线程和并行的世界</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/post/metrics-tracing-loging/">
            <span class="next-text nav-default">Metrics, tracing 和 logging 的关系</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:your@email.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-weibo" title="weibo"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
      <a href="http://localhost:1313" class="iconfont icon-douban" title="douban"></a>
      <a href="http://localhost:1313" class="iconfont icon-pocket" title="pocket"></a>
      <a href="http://localhost:1313" class="iconfont icon-tumblr" title="tumblr"></a>
      <a href="http://localhost:1313" class="iconfont icon-instagram" title="instagram"></a>
  <a href="http://www.cffyh.cc/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2017 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">刘超雄</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script>
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.min.js?v=2.7.0"></script>




</body>
</html>
